<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>PSDocling v3.1.0</title>
    <style>
        :root{
            --bg: #0f1115;
            --panel: #171a21;
            --panel-2: #1d2230;
            --stroke: #2a3244;
            --muted: #9aa3b2;
            --text: #e7eef7;
            --brand: #4db6ff;
            --brand-2:#0ea5e9;
            --ok:#10b981;
            --warn:#f59e0b;
            --err:#ef4444;
            --focus: #93c5fd;
            --ring: 0 0 0 3px rgba(147,197,253,.35);
            --radius: 14px;
            --shadow: 0 8px 30px rgba(0,0,0,.35);
        }
        @media (prefers-color-scheme: light){
            :root{
                --bg:#f7f9fc; --panel:#ffffff; --panel-2:#f4f7fb; --stroke:#d9e1ee;
                --muted:#5b6574; --text:#0e1726; --brand:#0369a1; --brand-2:#0284c7;
                --focus:#1d4ed8; --ring:0 0 0 3px rgba(29,78,216,.25);
                --shadow:0 8px 30px rgba(10,30,60,.08);
            }
        }

        *{box-sizing:border-box}
        html,body{height:100%; margin:0; padding:0}
        body{
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
            background:
                radial-gradient(1200px 1200px at -10% -10%, rgba(77,182,255,.08), transparent 55%),
                radial-gradient(1000px 1000px at 110% -20%, rgba(77,182,255,.08), transparent 55%),
                linear-gradient(180deg, var(--bg), var(--bg));
            color:var(--text);
            -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
        }

        .container{
            max-width:1200px;
            margin-inline:auto;
            padding:24px;
            display:grid;
            gap:20px;
        }

        /* Header */
        .header{
            background:linear-gradient(180deg, var(--panel), var(--panel-2));
            border:1px solid var(--stroke);
            border-radius:var(--radius);
            padding:24px;
            box-shadow:var(--shadow);
            position:sticky; top:16px; z-index:5;
        }
        .header-row{
            display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px;
        }
        .brand{
            display:flex; align-items:center; gap:12px;
        }
        .logo{
            width:36px; height:36px; border-radius:10px;
            background: radial-gradient(65% 65% at 35% 30%, var(--brand), transparent 60%),
                        linear-gradient(135deg, var(--brand-2), rgba(77,182,255,.25));
            border:1px solid var(--stroke);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 18px rgba(3, 169, 244, .08);
        }
        h1{
            margin:0; font-size: clamp(20px, 3.2vw, 28px); font-weight:700; letter-spacing:.2px;
            background: linear-gradient(45deg, var(--text), rgba(77,182,255,.9));
            -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
        }
        .badge{
            margin-left:6px;
            padding:4px 8px; border-radius:999px; font-size:.85rem; font-weight:600;
            color:var(--brand);
            background:linear-gradient(180deg, rgba(77,182,255,.10), rgba(77,182,255,.03));
            border:1px solid var(--stroke);
        }
        .subtitle{margin:6px 0 0 0; color:var(--muted)}
        .status{font-weight:600}
        .status-dot{
            width:8px;height:8px;border-radius:99px;display:inline-block;margin-right:6px;vertical-align:baseline;
            background:var(--warn); box-shadow:0 0 0 3px rgba(11, 132, 245, 0.2);
        }

        /* Card */
        .card{
            background:linear-gradient(180deg, var(--panel), var(--panel-2));
            border:1px solid var(--stroke); border-radius:var(--radius);
            padding:20px; box-shadow:var(--shadow);
        }
        .card-title{
            margin:0 0 10px 0; font-size:1.15rem; font-weight:700; letter-spacing:.2px;
            color:var(--brand);
        }

        /* Upload */
        .drop{
            border:1.5px dashed var(--stroke);
            border-radius:calc(var(--radius) - 4px);
            padding:28px; text-align:center; position:relative; overflow:hidden;
            background:linear-gradient(180deg, rgba(77,182,255,.06), transparent);
            transition:border-color .2s, transform .15s;
            outline:none;
        }
        .drop:hover{border-color:var(--brand); transform: translateY(-1px)}
        .drop:focus-visible{box-shadow: var(--ring); border-color:var(--focus)}
        .drop .shimmer{
            content:""; position:absolute; inset:0; translate:-100% 0;
            background:linear-gradient(90deg, transparent, rgba(77,182,255,.12), transparent);
            animation: sweep 2.6s linear infinite;
        }
        @keyframes sweep{to{translate:100% 0}}
        .drop h3{margin:6px 0 14px 0}
        .muted{color:var(--muted)}
        .kbd{
            padding:2px 6px; border-radius:6px; border:1px solid var(--stroke); background:rgba(0,0,0,.1);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
            font-size:.85em;
        }

        .btn{
            appearance:none; border:1px solid var(--stroke); background:linear-gradient(180deg, var(--brand-2), var(--brand));
            color:white; padding:10px 16px; border-radius:10px; font-weight:700; cursor:pointer;
            box-shadow:0 6px 18px rgba(77,182,255,.23); transition:transform .12s ease, box-shadow .2s ease, opacity .2s;
        }
        .btn:hover{transform:translateY(-1px); box-shadow:0 10px 24px rgba(77,182,255,.28)}
        .btn:disabled{opacity:.55; cursor:not-allowed; box-shadow:none}

        .btn-ghost{
            appearance:none; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(77,182,255,.06), rgba(77,182,255,.03));
            color:var(--brand); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer;
            transition:transform .12s ease, background .2s ease;
        }
        .btn-ghost:hover{transform:translateY(-1px); background:linear-gradient(180deg, rgba(77,182,255,.1), rgba(77,182,255,.06))}

        /* Stats */
        .stats{ display:grid; grid-template-columns: repeat(2, 1fr); gap:14px; }
        @media (min-width:780px){ .stats{grid-template-columns: repeat(4, 1fr);} }
        .stat{
            background:linear-gradient(180deg, var(--panel), var(--panel-2));
            border:1px solid var(--stroke); padding:16px; border-radius:12px; text-align:center;
            transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
        }
        .stat:hover{transform:translateY(-2px); border-color:rgba(77,182,255,.55); box-shadow:0 10px 24px rgba(77,182,255,.10)}
        .value{
            font-size:2.1rem; font-weight:800; line-height:1.1;
            background:linear-gradient(45deg, #fff, var(--brand)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
            margin-bottom:6px;
        }
        .label{color:var(--muted); letter-spacing:.12em; font-size:.8rem; text-transform:uppercase}

        /* Progress bar */
        .progress{height:10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid var(--stroke); overflow:hidden; margin: 15px 0; width: 100%;}
        .progress-bar{height:100%; width:0%; background:linear-gradient(90deg, var(--brand-2), var(--brand)); transition:width .25s ease}

        /* Status chips & wheel */
        .chip{padding:4px 8px; border-radius:999px; font-size:.85rem; font-weight:700; border:1px solid var(--stroke)}
        .status-ready{color:var(--brand)}
        .status-queued{color:var(--warn)}
        .status-processing{color:var(--brand)}
        .status-completed{color:var(--ok)}
        .status-error{color:var(--err); text-decoration:underline; cursor:pointer}
        .status-error:hover{opacity:.9}

        .wheel{width:16px; height:16px; border-radius:99px; border:2px solid rgba(255,255,255,.1); border-top:2px solid var(--brand); animation:spin 1s linear infinite}
        @keyframes spin{to{transform:rotate(360deg)}}
        .row{display:flex; align-items:center; gap:8px}

        /* Modal */
        .modal{display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:20; align-items:center; justify-content:center; padding:24px}
        .modal.in,.modal.show{display:flex}
        .modal-content{
            background:linear-gradient(180deg, var(--panel), var(--panel-2));
            width:min(920px, 92vw); max-height:85vh; overflow:auto;
            border:1px solid var(--stroke); border-radius:16px; box-shadow:var(--shadow); padding:20px; margin: 5% auto;
        }
        .modal-header{display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid var(--stroke); padding-bottom:12px; margin-bottom:12px}
        .close{cursor:pointer; font-size:26px; color:var(--muted); float:right}
        .close:hover{color:var(--text)}
        .error-section{margin:14px 0 20px 0; padding:12px 15px; border-left:4px solid var(--err); background:rgba(239,68,68,.06); border-radius:10px}
        .error-section h3{margin:0 0 10px 0; color:#ff8787}
        .error-code{
            background:#0b0d13; color:#e1e7f5; border:1px solid #242b3a; border-radius:10px;
            padding:12px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; font-size:12px; overflow:auto;
            white-space: pre-wrap; max-height: 200px; overflow-y: auto;
        }

        /* Utilities and legacy mappings */
        .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
        .hidden{display:none}
        details summary{cursor:pointer; color:var(--brand)}
        a.link{color:var(--brand); text-decoration:none}
        a.link:hover{text-decoration:underline}

        .stat-value { font-size:2.1rem; font-weight:800; line-height:1.1;
            background:linear-gradient(45deg, #fff, var(--brand)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; margin-bottom:6px; }
        .results { background:linear-gradient(180deg, var(--panel), var(--panel-2)); border:1px solid var(--stroke); border-radius:var(--radius); padding:20px; box-shadow:var(--shadow); }
        .results h3 { margin:0 0 10px 0; font-size:1.15rem; font-weight:700; letter-spacing:.2px; color:var(--brand); }
        .result-item { padding:16px; border-top:1px solid var(--stroke); display:flex; flex-direction:column; gap:10px }
        .result-item:first-child{border-top:none}
        .result-item:hover { background: rgba(77,182,255,.05); }
        .upload-area { border:1.5px dashed var(--stroke); border-radius:calc(var(--radius) - 4px); padding:28px; text-align:center; position:relative; overflow:hidden; background:linear-gradient(180deg, rgba(77,182,255,.06), transparent); transition:border-color .2s, transform .15s; }
        .upload-area:hover{border-color:var(--brand); transform: translateY(-1px)}
        .format-selector { background: var(--panel-2); border: 1px solid var(--stroke); color: var(--text); padding: 4px 8px; border-radius: 4px; margin: 0 8px; font-size: 0.85em; }
        .format-selector:focus { border-color: var(--brand); outline: none; box-shadow: var(--ring); }
        .reprocess-btn { appearance:none; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(77,182,255,.06), rgba(77,182,255,.03)); color:var(--brand); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; transition:transform .12s ease, background .2s ease; }
        .reprocess-btn:hover{transform:translateY(-1px); background:linear-gradient(180deg, rgba(77,182,255,.1), rgba(77,182,255,.06))}
        .progress-container { display: inline-flex; align-items: center; gap: 8px; }
        .progress-wheel { width:16px; height:16px; border-radius:99px; border:2px solid rgba(255,255,255,.1); border-top:2px solid var(--brand); animation:spin 1s linear infinite; display: inline-block; flex-shrink: 0; }
        .progress-text { font-size: 12px; color: var(--muted); }
        .download-all-btn { appearance:none; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(77,182,255,.06), rgba(77,182,255,.03)); color:var(--brand); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; transition:transform .12s ease, background .2s ease; }
        .download-all-btn:hover{transform:translateY(-1px); background:linear-gradient(180deg, rgba(77,182,255,.1), rgba(77,182,255,.06))}
        .start-btn { appearance:none; border:1px solid var(--stroke); background:linear-gradient(180deg, var(--brand-2), var(--brand)); color:white; padding:10px 16px; border-radius:10px; font-weight:700; cursor:pointer; box-shadow:0 6px 18px rgba(77,182,255,.23); transition:transform .12s ease, box-shadow .2s ease; }
        .start-btn:hover{transform:translateY(-1px); box-shadow:0 10px 24px rgba(77,182,255,.28)}
    </style>
</head>
<body>
    <main class="container">
        <!-- Header -->
        <section class="header" role="banner" aria-label="PSDocling header">
            <div class="header-row">
                <div class="brand">
                    <div class="logo" aria-hidden="true"></div>
                    <div>
                        <h1>PSDocling <span class="badge" aria-label="version">v3.1.0</span></h1>
                        <p class="subtitle">PowerShell-based Document Processor for Docling</p>
                    </div>
                </div>
                <div class="row" aria-live="polite">
                    <span class="status"><span class="status-dot" id="status-dot"></span>Backend Status: <span id="status">Connecting...</span></span>
                </div>
            </div>
        </section>

        <!-- Upload -->
        <section class="card" aria-labelledby="upload-title">
            <h2 class="card-title" id="upload-title">Upload</h2>
            <div class="drop" id="drop-zone" tabindex="0" role="button" aria-label="Drop files here or press Enter to browse">
                <div class="shimmer" aria-hidden="true"></div>
                <h3>Drop files here or <span class="link" onclick="document.getElementById('file-input').click()">browse</span></h3>
                <p class="muted">Max 100MB per file • Press <span class="kbd">Enter</span> to open file picker</p>
                <button class="btn" style="margin-top:10px" onclick="document.getElementById('file-input').click()">Choose Files</button>
                <input type="file" id="file-input" multiple accept=".pdf,.docx,.xlsx,.pptx,.md,.html,.xhtml,.csv,.png,.jpg,.jpeg,.tiff,.bmp,.webp" class="sr-only" aria-hidden="true" />
                <div style="margin-top:18px">
                    <span class="pill">PDF</span>
                    <span class="pill">DOCX</span>
                    <span class="pill">XLSX</span>
                    <span class="pill">PPTX</span>
                    <span class="pill">MD</span>
                    <span class="pill">HTML</span>
                    <span class="pill">CSV</span>
                    <span class="pill">Images</span>
                </div>
            </div>

            <div id="upload-progress" class="card" style="margin-top:14px; display:none">
                <div class="row" style="justify-content:space-between">
                    <p class="muted" style="margin:0">Uploading files…</p>
                    <span class="chip">Transfer</span>
                </div>
                <div class="progress" style="margin-top:10px"><div class="progress-bar" id="progress-bar"></div></div>
            </div>
        </section>

        <!-- Stats -->
        <section class="card" aria-labelledby="stats-title">
            <h2 class="card-title" id="stats-title">Queue Overview</h2>
            <div class="stats" role="list">
                <div class="stat" role="listitem" aria-live="polite">
                    <div class="value" id="queued">0</div>
                    <div class="label">Queued</div>
                </div>
                <div class="stat" role="listitem" aria-live="polite">
                    <div class="value" id="processing">0</div>
                    <div class="label">Processing</div>
                </div>
                <div class="stat" role="listitem" aria-live="polite">
                    <div class="value" id="completed">0</div>
                    <div class="label">Completed</div>
                </div>
                <div class="stat" role="listitem" aria-live="polite">
                    <div class="value" id="errors">0</div>
                    <div class="label">Errors</div>
                </div>
            </div>
        </section>

        <!-- Processing Results -->
        <section class="card" aria-labelledby="results-title" id="results">
            <h2 class="card-title" id="results-title">Processing Results</h2>
            <div id="results-list" class="results-list"></div>
        </section>

        <!-- Processed Files -->
        <section class="card" aria-labelledby="files-title">
            <div class="row" style="justify-content:space-between">
                <h2 class="card-title" id="files-title" style="margin:0">Processed Files</h2>
                <button class="btn-ghost" onclick="downloadAllDocuments()">Download All</button>
            </div>
            <div id="files-list" style="margin-top:10px">
                <p class="muted" style="font-style:italic">Loading processed files…</p>
            </div>
        </section>
    </main>

    <!-- Error Modal -->
    <div id="errorModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="error-modal-title">
        <div class="modal-card">
            <div class="modal-header">
                <h2 class="card-title" id="error-modal-title" style="margin:0">Error Details</h2>
                <span class="close" aria-label="Close error details" role="button">&times;</span>
            </div>
            <div id="errorModalContent">
                <p class="muted">Loading error details…</p>
            </div>
        </div>
    </div>

    <script>
    const API = 'http://localhost:8080';
    const results = {};

    document.addEventListener('DOMContentLoaded', function() {
        setupUpload();

        // Keyboard support for drop zone
        const zone = document.getElementById('drop-zone');
        zone.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                document.getElementById('file-input').click();
            }
        });

        // Delay initial API calls to give server time to start
        setTimeout(async () => {
            const isHealthy = await checkHealth();
            if (isHealthy) {
                loadExistingDocuments();
                loadProcessedFiles();
            }
        }, 600);

        setInterval(loadProcessedFiles, 2000);
        setInterval(updateStats, 2000);
    });

    function setupUpload() {
        const zone = document.getElementById('drop-zone');
        const input = document.getElementById('file-input');

        zone.addEventListener('dragover', e => {
            e.preventDefault();
            zone.style.borderColor = 'var(--brand)';
        });
        zone.addEventListener('dragleave', () => {
            zone.style.borderColor = 'var(--stroke)';
        });
        zone.addEventListener('drop', e => {
            e.preventDefault();
            zone.style.borderColor = 'var(--stroke)';
            handleFiles(e.dataTransfer.files);
        });
        input.addEventListener('change', e => handleFiles(e.target.files));
    }

    async function handleFiles(files) {
        const progress = document.getElementById('upload-progress');
        const bar = document.getElementById('progress-bar');

        progress.style.display = 'block';

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            try {
                // Check file size limit (100MB)
                const maxSizeBytes = 100 * 1024 * 1024;  // 100MB
                if (file.size > maxSizeBytes) {
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                    alert('File "' + file.name + '" (' + sizeMB + ' MB) exceeds the 100MB size limit. Please upload a smaller file.');
                    continue;  // Skip this file
                }

                // Use FileReader for reliable base64 conversion
                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        const base64Data = result.substring(result.indexOf(',') + 1);
                        resolve(base64Data);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });

                // Default enrichment options for initial upload (user selects them later)
                const enrichCode = false;
                const enrichFormula = false;
                const enrichPictureClasses = false;
                const enrichPictureDescription = false;

                const response = await fetch(API + '/api/upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: file.name,
                        dataBase64: base64,
                        enrichCode: enrichCode,
                        enrichFormula: enrichFormula,
                        enrichPictureClasses: enrichPictureClasses,
                        enrichPictureDescription: enrichPictureDescription
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    addResult(result.documentId, file.name);
                    // Don't start polling - document should stay in Ready status for manual conversion
                } else {
                    throw new Error('Upload failed');
                }
            } catch (error) {
                alert('Error uploading ' + file.name + ': ' + error.message);
            }

            bar.style.width = ((i + 1) / files.length * 100) + '%';
        }

        setTimeout(() => { progress.style.display = 'none'; bar.style.width = '0%'; }, 1000);
    }

    // Validate export format selection
    function validateExportFormat(id) {
        const radioButtons = document.querySelectorAll('input[name="format-' + id + '"]');
        const validationMsg = document.getElementById('validation-' + id);
        const startBtn = document.getElementById('start-' + id);

        let selectedCount = 0;
        radioButtons.forEach(radio => {
            if (radio.checked) selectedCount++;
        });

        if (selectedCount === 1) {
            validationMsg.style.display = 'none';
            startBtn.disabled = false;
            startBtn.style.opacity = '1';
            startBtn.style.cursor = 'pointer';
        } else {
            validationMsg.style.display = 'block';
            startBtn.disabled = true;
            startBtn.style.opacity = '0.5';
            startBtn.style.cursor = 'not-allowed';
        }
    }

    function toggleChunkingOptions(id) {
        const checkbox = document.getElementById('enableChunking-' + id);
        const details = document.getElementById('chunkingDetails-' + id);
        if (checkbox.checked) {
            details.style.display = 'block';
        } else {
            details.style.display = 'none';
        }
    }

    function toggleTokenizerOptions(id) {
        const backend = document.getElementById('chunkTokenizerBackend-' + id).value;
        const hfOptions = document.getElementById('hfTokenizerOptions-' + id);
        const openaiOptions = document.getElementById('openaiTokenizerOptions-' + id);

        if (backend === 'hf') {
            hfOptions.style.display = 'block';
            openaiOptions.style.display = 'none';
        } else {
            hfOptions.style.display = 'none';
            openaiOptions.style.display = 'block';
        }
    }

    // Apply model preset
    function applyModelPreset(id) {
        const preset = document.getElementById('chunkModelPreset-' + id).value;
        const modelPresets = {
            'general': { backend: 'hf', model: 'sentence-transformers/all-MiniLM-L6-v2', maxTokens: 512 },
            'legal': { backend: 'hf', model: 'nlpaueb/legal-bert-base-uncased', maxTokens: 512 },
            'medical': { backend: 'hf', model: 'dmis-lab/biobert-v1.1', maxTokens: 256 },
            'financial': { backend: 'hf', model: 'yiyanghkust/finbert-tone', maxTokens: 512 },
            'scientific': { backend: 'hf', model: 'allenai/scibert_scivocab_uncased', maxTokens: 256 },
            'multilingual': { backend: 'hf', model: 'bert-base-multilingual-cased', maxTokens: 400 },
            'code': { backend: 'hf', model: 'microsoft/codebert-base', maxTokens: 512 }
        };

        if (preset && modelPresets[preset]) {
            const config = modelPresets[preset];
            document.getElementById('chunkTokenizerBackend-' + id).value = config.backend;
            document.getElementById('chunkTokenizerModel-' + id).value = config.model;
            document.getElementById('chunkMaxTokens-' + id).value = config.maxTokens;
            toggleTokenizerOptions(id);

            if (preset === 'code') {
                document.getElementById('chunkPreserveCode-' + id).checked = true;
                document.getElementById('chunkTableSerialization-' + id).value = 'markdown';
            } else if (preset === 'legal' || preset === 'medical') {
                document.getElementById('chunkPreserveSentences-' + id).checked = true;
                document.getElementById('chunkIncludeContext-' + id).checked = true;
            } else if (preset === 'financial') {
                document.getElementById('chunkTableSerialization-' + id).value = 'csv';
            }
        }
    }

    // Toggle image placeholder field visibility
    document.addEventListener('change', function(e) {
        if (e.target && e.target.id && e.target.id.startsWith('chunkPictureStrategy-')) {
            const id = e.target.id.replace('chunkPictureStrategy-', '');
            const placeholderDiv = document.getElementById('imagePlaceholderDiv-' + id);
            if (e.target.value === 'placeholder') {
                placeholderDiv.style.display = 'block';
            } else {
                placeholderDiv.style.display = 'none';
            }
        }
    });

    function addResult(id, name, currentFormat = 'markdown') {
        const list = document.getElementById('results-list');

        // Remove placeholder message if it exists
        const placeholder = list.querySelector('p');
        if (placeholder && placeholder.textContent.includes('No documents in processing')) {
            placeholder.remove();
        }

        const item = document.createElement('div');
        item.className = 'result-item';
        item.id = 'result-item-' + id;
        item.innerHTML =
            '<div style="width: 100%;">' +
                '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">' +
                    '<strong>' + name + '</strong>' +
                    '<span id="status-' + id + '" class="status-ready">Ready</span>' +
                '</div>' +
                '<div id="validation-' + id + '" style="color: #ef4444; font-size: 0.85em; margin-bottom: 10px; display: none;">&#9888; Select a single export format</div>' +
                '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 15px;">' +
                    '<div style="padding: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid #404040;">' +
                        '<h4 style="margin: 0 0 10px 0; color: #049fd9; font-size: 1em; font-weight: bold;">Export Formats</h4>' +
                        '<div style="display: flex; flex-direction: column; gap: 6px; font-size: 0.9em;">' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="radio" name="format-' + id + '" value="markdown"' + (currentFormat === 'markdown' ? ' checked' : '') + ' style="margin: 0;" onchange="validateExportFormat(\'' + id + '\')">' +
                                '<span>Markdown (.md)</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="radio" name="format-' + id + '" value="html"' + (currentFormat === 'html' ? ' checked' : '') + ' style="margin: 0;" onchange="validateExportFormat(\'' + id + '\')">' +
                                '<span>HTML (.html)</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="radio" name="format-' + id + '" value="json"' + (currentFormat === 'json' ? ' checked' : '') + ' style="margin: 0;" onchange="validateExportFormat(\'' + id + '\')">' +
                                '<span>JSON (.json)</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="radio" name="format-' + id + '" value="text"' + (currentFormat === 'text' ? ' checked' : '') + ' style="margin: 0;" onchange="validateExportFormat(\'' + id + '\')">' +
                                '<span>Plain Text (.txt)</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="radio" name="format-' + id + '" value="doctags"' + (currentFormat === 'doctags' ? ' checked' : '') + ' style="margin: 0;" onchange="validateExportFormat(\'' + id + '\')">' +
                                '<span>DocTags (.xml)</span>' +
                            '</label>' +
                        '</div>' +
                        '<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #404040;">' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9em;">' +
                                '<input type="checkbox" id="embedImages-' + id + '" style="margin: 0;">' +
                                '<span>Embed Images</span>' +
                            '</label>' +
                        '</div>' +
                    '</div>' +
                    '<div style="padding: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid #404040;">' +
                        '<h4 style="margin: 0 0 10px 0; color: #049fd9; font-size: 1em; font-weight: bold;">Enrichment Options</h4>' +
                        '<div style="display: flex; flex-direction: column; gap: 6px; font-size: 0.9em;">' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="checkbox" id="enrichCode-' + id + '" style="margin: 0;">' +
                                '<span>Code Understanding</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="checkbox" id="enrichFormula-' + id + '" style="margin: 0;">' +
                                '<span>Formula Understanding</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="checkbox" id="enrichPictureClasses-' + id + '" style="margin: 0;">' +
                                '<span>Picture Classification</span>' +
                            '</label>' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                '<input type="checkbox" id="enrichPictureDescription-' + id + '" style="margin: 0;">' +
                                '<span>Picture Description</span>' +
                            '</label>' +
                        '</div>' +
                    '</div>' +
                    '<div style="padding: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid #404040;">' +
                        '<h4 style="margin: 0 0 10px 0; color: #049fd9; font-size: 1em; font-weight: bold;">Chunking Options</h4>' +
                        '<div style="display: flex; flex-direction: column; gap: 6px; font-size: 0.9em;">' +
                            '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 8px;">' +
                                '<input type="checkbox" id="enableChunking-' + id + '" style="margin: 0;" onchange="toggleChunkingOptions(\'' + id + '\')">' +
                                '<span><strong>Enable Hybrid Chunking</strong></span>' +
                            '</label>' +
                            '<div id="chunkingDetails-' + id + '" style="display: none; padding-left: 20px; border-left: 2px solid #404040;">' +
                                '<div style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #049fd9; font-size: 0.85em; font-weight: bold;">Model Preset:</label>' +
                                    '<select id="chunkModelPreset-' + id + '" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.9em;" onchange="applyModelPreset(\'' + id + '\')">' +
                                        '<option value="">Custom Configuration</option>' +
                                        '<option value="general" selected>General Purpose</option>' +
                                        '<option value="legal">Legal Documents</option>' +
                                        '<option value="medical">Medical/Clinical</option>' +
                                        '<option value="financial">Financial Reports</option>' +
                                        '<option value="scientific">Scientific Papers</option>' +
                                        '<option value="multilingual">Multilingual Content</option>' +
                                        '<option value="code">Code/Technical Docs</option>' +
                                    '</select>' +
                                '</div>' +
                                '<div style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">Tokenizer Backend:</label>' +
                                    '<select id="chunkTokenizerBackend-' + id + '" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.9em;" onchange="toggleTokenizerOptions(\'' + id + '\')">' +
                                        '<option value="hf">HuggingFace</option>' +
                                        '<option value="openai">OpenAI (tiktoken)</option>' +
                                    '</select>' +
                                '</div>' +
                                '<div id="hfTokenizerOptions-' + id + '" style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">HF Model:</label>' +
                                    '<input type="text" id="chunkTokenizerModel-' + id + '" value="sentence-transformers/all-MiniLM-L6-v2" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.85em;">' +
                                '</div>' +
                                '<div id="openaiTokenizerOptions-' + id + '" style="margin-bottom: 8px; display: none;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">OpenAI Model:</label>' +
                                    '<input type="text" id="chunkOpenAIModel-' + id + '" value="gpt-4o-mini" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.85em;">' +
                                '</div>' +
                                '<div style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">Max Tokens:</label>' +
                                    '<input type="number" id="chunkMaxTokens-' + id + '" value="512" min="50" max="8192" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.85em;">' +
                                '</div>' +
                                '<div style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #049fd9; font-size: 0.85em; font-weight: bold;">Table Format:</label>' +
                                    '<select id="chunkTableSerialization-' + id + '" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.9em;">' +
                                        '<option value="triplets">Triplets (Default)</option>' +
                                        '<option value="markdown">Markdown Tables</option>' +
                                        '<option value="csv">CSV Format</option>' +
                                        '<option value="grid">ASCII Grid</option>' +
                                    '</select>' +
                                '</div>' +
                                '<div style="margin-bottom: 8px;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #049fd9; font-size: 0.85em; font-weight: bold;">Picture Handling:</label>' +
                                    '<select id="chunkPictureStrategy-' + id + '" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.9em;">' +
                                        '<option value="default">Default</option>' +
                                        '<option value="with_caption">Include Captions</option>' +
                                        '<option value="with_description">Include Descriptions</option>' +
                                        '<option value="placeholder">Custom Placeholder</option>' +
                                    '</select>' +
                                '</div>' +
                                '<div id="imagePlaceholderDiv-' + id + '" style="margin-bottom: 8px; display: none;">' +
                                    '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">Image Placeholder Text:</label>' +
                                    '<input type="text" id="chunkImagePlaceholder-' + id + '" value="[IMAGE]" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.85em;">' +
                                '</div>' +
                                '<div style="border-top: 1px solid #404040; margin-top: 10px; padding-top: 10px;">' +
                                    '<label style="display: block; margin-bottom: 6px; color: #049fd9; font-size: 0.85em; font-weight: bold;">Advanced Options:</label>' +
                                    '<div style="margin-bottom: 8px;">' +
                                        '<label style="display: block; margin-bottom: 4px; color: #aaa; font-size: 0.85em;">Overlap Tokens (0 = disabled):</label>' +
                                        '<input type="number" id="chunkOverlapTokens-' + id + '" value="0" min="0" max="1000" style="width: 100%; padding: 4px; background: #1a1a1a; color: white; border: 1px solid #404040; border-radius: 4px; font-size: 0.85em;">' +
                                    '</div>' +
                                    '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 6px; font-size: 0.85em;">' +
                                        '<input type="checkbox" id="chunkMergePeers-' + id + '" checked style="margin: 0;">' +
                                        '<span>Merge Undersized Peers</span>' +
                                    '</label>' +
                                    '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 6px; font-size: 0.85em;">' +
                                        '<input type="checkbox" id="chunkIncludeContext-' + id + '" style="margin: 0;">' +
                                        '<span>Include Contextualized Text</span>' +
                                    '</label>' +
                                    '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 6px; font-size: 0.85em;">' +
                                        '<input type="checkbox" id="chunkPreserveSentences-' + id + '" style="margin: 0;">' +
                                        '<span>Preserve Sentence Boundaries</span>' +
                                    '</label>' +
                                    '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.85em;">' +
                                        '<input type="checkbox" id="chunkPreserveCode-' + id + '" style="margin: 0;">' +
                                        '<span>Preserve Code Blocks</span>' +
                                    '</label>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                    '<div id="download-buttons-' + id + '" style="display:none;">' +
                        '<button class="download-btn" onclick="downloadDocument(\'" + id + "\')" style="margin-right: 10px;">Download</button>' +
                    '</div>' +
                    '<div style="display: flex; gap: 8px;">' +
                        '<button class="start-btn" onclick="startConversion(\'' + id + '\')" id="start-' + id + '" disabled>Start Conversion</button>' +
                        '<button class="reprocess-btn" onclick="reprocessDocument(\'' + id + '\')" style="display:none" id="reprocess-' + id + '">Re-process</button>' +
                    '</div>' +
                '</div>' +
            '</div>';
        list.appendChild(item);
        results[id] = { name: name, format: currentFormat };

        validateExportFormat(id);
    }

    async function startConversion(id) {
        const radioButtons = document.querySelectorAll('input[name="format-' + id + '"]');
        let selectedFormat = null;
        radioButtons.forEach(radio => { if (radio.checked) selectedFormat = radio.value; });
        if (!selectedFormat) { alert('Please select an export format'); return; }

        const embedImages = document.getElementById('embedImages-' + id).checked;
        const enrichCode = document.getElementById('enrichCode-' + id).checked;
        const enrichFormula = document.getElementById('enrichFormula-' + id).checked;
        const enrichPictureClasses = document.getElementById('enrichPictureClasses-' + id).checked;
        const enrichPictureDescription = document.getElementById('enrichPictureDescription-' + id).checked;

        const enableChunking = document.getElementById('enableChunking-' + id).checked;
        let chunkingParams = {};
        if (enableChunking) {
            const backend = document.getElementById('chunkTokenizerBackend-' + id).value;
            chunkingParams = {
                enableChunking: true,
                chunkTokenizerBackend: backend,
                chunkMaxTokens: parseInt(document.getElementById('chunkMaxTokens-' + id).value),
                chunkMergePeers: document.getElementById('chunkMergePeers-' + id).checked,
                chunkIncludeContext: document.getElementById('chunkIncludeContext-' + id).checked
            };
            if (backend === 'hf') {
                chunkingParams.chunkTokenizerModel = document.getElementById('chunkTokenizerModel-' + id).value;
            } else {
                chunkingParams.chunkOpenAIModel = document.getElementById('chunkOpenAIModel-' + id).value;
            }
        }

        const statusElement = document.getElementById('status-' + id);
        const startBtn = document.getElementById('start-' + id);

        try {
            startBtn.style.display = 'none';
            statusElement.textContent = 'Queued...';
            statusElement.className = 'status-queued';

            const response = await fetch(API + '/api/start-conversion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    documentId: id,
                    exportFormat: selectedFormat,
                    embedImages,
                    enrichCode,
                    enrichFormula,
                    enrichPictureClasses,
                    enrichPictureDescription,
                    ...chunkingParams
                })
            });

            if (response.ok) {
                if (results[id] && typeof results[id] === 'object') { results[id].format = selectedFormat; }
                else { results[id] = { name: results[id] || 'Unknown', format: selectedFormat }; }
                setTimeout(() => pollResult(id, results[id].name || 'Unknown'), 500);
            } else {
                throw new Error('Failed to start conversion');
            }
        } catch (error) {
            statusElement.textContent = 'Error (click for details)';
            statusElement.className = 'status-error';
            statusElement.onclick = () => showErrorDetails(id, results[id].name || 'Unknown');
            startBtn.style.display = 'inline';
            console.error('Start conversion error:', error);
        }
    }

    async function reprocessDocument(id) {
        const radioButtons = document.querySelectorAll('input[name="format-' + id + '"]');
        let newFormat = null;
        radioButtons.forEach(radio => { if (radio.checked) newFormat = radio.value; });
        if (!newFormat) { alert('Please select an export format'); return; }

        const embedImages = document.getElementById('embedImages-' + id).checked;
        const enrichCode = document.getElementById('enrichCode-' + id).checked;
        const enrichFormula = document.getElementById('enrichFormula-' + id).checked;
        const enrichPictureClasses = document.getElementById('enrichPictureClasses-' + id).checked;
        const enrichPictureDescription = document.getElementById('enrichPictureDescription-' + id).checked;

        const enableChunking = document.getElementById('enableChunking-' + id).checked;
        let chunkingParams = {};
        if (enableChunking) {
            const backend = document.getElementById('chunkTokenizerBackend-' + id).value;
            chunkingParams = {
                enableChunking: true,
                chunkTokenizerBackend: backend,
                chunkMaxTokens: parseInt(document.getElementById('chunkMaxTokens-' + id).value),
                chunkMergePeers: document.getElementById('chunkMergePeers-' + id).checked,
                chunkIncludeContext: document.getElementById('chunkIncludeContext-' + id).checked
            };
            if (backend === 'hf') {
                chunkingParams.chunkTokenizerModel = document.getElementById('chunkTokenizerModel-' + id).value;
            } else {
                chunkingParams.chunkOpenAIModel = document.getElementById('chunkOpenAIModel-' + id).value;
            }
        }

        const statusElement = document.getElementById('status-' + id);
        const reprocessBtn = document.getElementById('reprocess-' + id);

        try {
            reprocessBtn.style.display = 'none';
            statusElement.textContent = 'Re-processing...';
            statusElement.className = 'status-processing';

            const response = await fetch(API + '/api/reprocess', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    documentId: id,
                    exportFormat: newFormat,
                    embedImages,
                    enrichCode,
                    enrichFormula,
                    enrichPictureClasses,
                    enrichPictureDescription,
                    ...chunkingParams
                })
            });

            if (response.ok) {
                if (results[id] && typeof results[id] === 'object') { results[id].format = newFormat; }
                else { results[id] = { name: results[id] || 'Unknown', format: newFormat }; }
                setTimeout(() => pollResult(id, results[id].name || 'Unknown'), 500);
            } else {
                throw new Error('Failed to reprocess document');
            }
        } catch (error) {
            statusElement.textContent = 'Error (click for details)';
            statusElement.className = 'status-error';
            statusElement.onclick = () => showErrorDetails(id, results[id].name || 'Unknown');
            console.error('Reprocess error:', error);
        }
    }

    function showErrorDetails(id, fileName) {
        const modal = document.getElementById('errorModal');
        const content = document.getElementById('errorModalContent');

        content.innerHTML = '<p>Loading error details...</p>';
        modal.style.display = 'block';
        modal.classList.add('show');

        fetch(API + '/api/error/' + id)
            .then(response => response.ok ? response.json() : response.text().then(t => { throw new Error('HTTP ' + response.status + ': ' + t); }))
            .then(errorData => { content.innerHTML = formatErrorDetails(errorData); })
            .catch(error => { content.innerHTML = '<p style="color: #ef4444;">Failed to load error details: ' + error.message + '</p>'; });
    }

    function formatEstimatedTime(estimatedDurationMs, elapsedTimeMs) {
        if (!estimatedDurationMs || !elapsedTimeMs) return '';
        const remainingMs = Math.max(0, estimatedDurationMs - elapsedTimeMs);
        const remainingSeconds = Math.round(remainingMs / 1000);
        if (remainingSeconds <= 0) return 'finishing...';
        if (remainingSeconds < 60) return remainingSeconds + 's remaining';
        const remainingMinutes = Math.floor(remainingSeconds / 60);
        const seconds = remainingSeconds % 60;
        if (remainingMinutes < 60) { return seconds > 0 ? remainingMinutes + 'm ' + seconds + 's remaining' : remainingMinutes + 'm remaining'; }
        const hours = Math.floor(remainingMinutes / 60);
        const minutes = remainingMinutes % 60;
        return minutes > 0 ? hours + 'h ' + minutes + 'm remaining' : hours + 'h remaining';
    }

    function formatErrorDetails(errorData) {
        let html = '<div class="error-section">';
        html += '<h3>File Information</h3>';
        html += '<p><strong>File:</strong> ' + (errorData.fileName || 'Unknown') + '</p>';
        html += '<p><strong>Document ID:</strong> ' + errorData.id + '</p>';
        html += '<p><strong>Queued:</strong> ' + (errorData.queuedTime?.DateTime || errorData.queuedTime || 'Unknown') + '</p>';

        if (errorData.currentStatus && errorData.currentStatus !== 'Error') {
            html += '<p><strong>Current Status:</strong> ' + errorData.currentStatus + '</p>';
            if (errorData.startTime) { html += '<p><strong>Started:</strong> ' + (errorData.startTime?.DateTime || errorData.startTime || 'Unknown') + '</p>'; }
            if (errorData.progress !== undefined) { html += '<p><strong>Progress:</strong> ' + errorData.progress + '%</p>'; }
            html += '</div><div class="error-section">';
            html += '<h3>Status Information</h3>';
            html += '<div class="error-code" style="background: #1a2e1a; border-left: 4px solid #10b981;">' + (errorData.message || 'Document is being processed') + '</div>';
            html += '</div>';
        } else {
            html += '<p><strong>Failed:</strong> ' + (errorData.endTime?.DateTime || errorData.endTime || 'Unknown') + '</p></div>';
            html += '<div class="error-section"><h3>Error Message</h3><div class="error-code">' + (errorData.error || 'No error message available') + '</div></div>';
        }

        if (errorData.stderr && typeof errorData.stderr === 'string' && errorData.stderr.trim()) {
            html += '<div class="error-section"><h3>Python Error Output (stderr)</h3><div class="error-code">' + errorData.stderr + '</div></div>';
        }

        if (errorData.errorDetails) {
            html += '<div class="error-section"><h3>Technical Details</h3>';
            if (errorData.errorDetails.ExceptionType) { html += '<p><strong>Exception Type:</strong> ' + errorData.errorDetails.ExceptionType + '</p>'; }
            if (errorData.errorDetails.InnerException) { html += '<p><strong>Inner Exception:</strong> ' + errorData.errorDetails.InnerException + '</p>'; }
            if (errorData.errorDetails.StackTrace) { html += '<h4>Stack Trace:</h4><div class="error-code">' + errorData.errorDetails.StackTrace + '</div>'; }
            if (errorData.errorDetails.ScriptStackTrace) { html += '<h4>Script Stack Trace:</h4><div class="error-code">' + errorData.errorDetails.ScriptStackTrace + '</div>'; }
            html += '</div>';
        }
        return html;
    }

    // Modal close / keyboard support
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('errorModal');
        const closeBtn = document.querySelector('.close');

        closeBtn.onclick = function() {
            modal.style.display = 'none';
            modal.classList.remove('show', 'in');
        }
        window.onclick = function(event) {
            if (event.target === modal) {
                modal.style.display = 'none';
                modal.classList.remove('show', 'in');
            }
        }
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && (modal.classList.contains('show') || modal.classList.contains('in') || modal.style.display === 'flex')) {
                modal.style.display = 'none';
                modal.classList.remove('show', 'in');
            }
        });
    });

    async function pollResult(id, name, attempt = 0) {
        try {
            const response = await fetch(API + '/api/result/' + id);
            if (response.status === 200) {
                const contentLength = response.headers.get('content-length');
                const blob = await response.blob();

                document.getElementById('status-' + id).textContent = 'Completed';
                const link = document.getElementById('link-' + id);

                if ((contentLength && parseInt(contentLength) > 5 * 1024 * 1024) ||
                    (blob.type.includes('json') && blob.size > 1 * 1024 * 1024)) {
                    link.href = API + '/api/result/' + id;
                    link.download = name + '.' + (blob.type.includes('json') ? 'json' : 'md');
                    link.textContent = 'View File (' + (blob.size / (1024 * 1024)).toFixed(1) + ' MB)';
                } else {
                    const url = URL.createObjectURL(blob);
                    link.href = url;
                }

                document.getElementById('download-buttons-' + id).style.display = 'inline';
                loadProcessedFiles();
                updateStats();
                return;
            }
            if (response.status === 202) {
                try {
                    const documentsResponse = await fetch(API + '/api/documents');
                    if (documentsResponse.ok) {
                        const documents = await documentsResponse.json();
                        const doc = documents.find(d => d.id === id);
                        if (doc && doc.status === 'Processing') {
                            const statusElement = document.getElementById('status-' + id);
                            let progressText = 'Processing...';
                            let elapsedText = '';

                            if (doc.elapsedTime) {
                                const elapsedMs = doc.elapsedTime;
                                const elapsedSeconds = Math.floor(elapsedMs / 1000);
                                const hours = Math.floor(elapsedSeconds / 3600);
                                const minutes = Math.floor((elapsedSeconds % 3600) / 60);
                                const seconds = elapsedSeconds % 60;
                                if (hours > 0) { elapsedText = hours + 'h ' + minutes + 'm'; }
                                else if (minutes > 0) { elapsedText = minutes + 'm ' + seconds + 's'; }
                                else { elapsedText = seconds + 's'; }
                            }

                            if (doc.enhancementsInProgress && doc.activeEnhancements && doc.activeEnhancements.length > 0) {
                                const enhancement = doc.activeEnhancements[0];
                                progressText = 'Processing (' + enhancement + ')';
                                if (doc.progress !== undefined && doc.progress !== null) {
                                    progressText = 'Processing (' + enhancement + ') ' + doc.progress + '%';
                                }
                            } else if (doc.progress !== undefined && doc.progress !== null) {
                                progressText = 'Processing ' + doc.progress + '%';
                            }
                            if (elapsedText) { progressText += ' - ' + elapsedText + ' elapsed'; }
                            if (doc.elapsedTime && doc.elapsedTime > 900000) {
                                progressText += '<br><span style="font-size: 0.85em; color: #fbbf24;">Still processing, please be patient...</span>';
                            }

                            statusElement.innerHTML = '<div class="progress-container"><div class="progress-wheel"></div><span>' + progressText + '</span></div>';

                            const linkElement = document.getElementById('link-' + id);
                            if (doc.elapsedTime && doc.elapsedTime > 300000) {
                                if (!document.getElementById('cancel-' + id)) {
                                    const cancelBtn = document.createElement('button');
                                    cancelBtn.id = 'cancel-' + id;
                                    cancelBtn.textContent = 'Cancel';
                                    cancelBtn.style = 'padding: 4px 8px; margin-left: 8px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;';
                                    cancelBtn.onclick = () => cancelProcessing(id, name);
                                    linkElement?.parentNode?.insertBefore(cancelBtn, linkElement);
                                }
                            }
                        }
                    }
                } catch (e) {
                    document.getElementById('status-' + id).textContent = 'Processing...';
                }
                setTimeout(() => pollResult(id, name, attempt + 1), 1000);
                return;
            }

            try {
                const documentsResponse = await fetch(API + '/api/documents');
                if (documentsResponse.ok) {
                    const documents = await documentsResponse.json();
                    const doc = documents.find(d => d.id === id);
                    if (doc && doc.status === 'Error') {
                        const statusElement = document.getElementById('status-' + id);
                        statusElement.textContent = 'Error (click for details)';
                        statusElement.className = 'status-error';
                        statusElement.onclick = () => showErrorDetails(id, name);
                        return;
                    } else if (doc) {
                        setTimeout(() => pollResult(id, name, attempt + 1), 2000);
                        return;
                    }
                }
            } catch (docError) {
                console.log('Failed to check document status:', docError);
            }

            const statusElement = document.getElementById('status-' + id);
            statusElement.textContent = 'Connection Error - Retrying...';
            statusElement.className = 'status-error';
            statusElement.onclick = null;
        } catch (error) {
            if (attempt < 30) {
                setTimeout(() => pollResult(id, name, attempt + 1), 2000);
            } else {
                try {
                    const documentsResponse = await fetch(API + '/api/documents');
                    if (documentsResponse.ok) {
                        const documents = await documentsResponse.json();
                        const doc = documents.find(d => d.id === id);
                        if (doc && doc.status === 'Error') {
                            const statusElement = document.getElementById('status-' + id);
                            statusElement.textContent = 'Error (click for details)';
                            statusElement.className = 'status-error';
                            statusElement.onclick = () => showErrorDetails(id, name);
                            return;
                        }
                    }
                } catch (docError) {
                    console.log('Failed to check document status after retries:', docError);
                }
                const statusElement = document.getElementById('status-' + id);
                statusElement.textContent = 'Connection Lost';
                statusElement.className = 'status-error';
                statusElement.onclick = null;
            }
        }
    }

    async function updateStats() {
        try {
            const response = await fetch(API + '/api/status');
            if (response.ok) {
                const stats = await response.json();
                document.getElementById('queued').textContent = stats.QueuedCount || 0;
                document.getElementById('processing').textContent = stats.ProcessingCount || 0;
                document.getElementById('completed').textContent = stats.CompletedCount || 0;
                document.getElementById('errors').textContent = stats.ErrorCount || 0;
            } else {
                console.error('Stats update failed with status:', response.status);
                setTimeout(() => checkHealth(1), 1000);
            }
        } catch (error) {
            console.error('Stats update failed:', error);
            setTimeout(() => checkHealth(1), 1000);
        }
    }

    async function loadExistingDocuments() {
        try {
            const response = await fetch(API + '/api/documents');
            if (response.ok) {
                const documents = await response.json();
                const list = document.getElementById('results-list');
                list.innerHTML = '';

                documents.forEach(doc => {
                    if (doc.status === 'Completed') { return; }
                    const docFormat = doc.exportFormat || 'markdown';
                    addResult(doc.id, doc.fileName, docFormat);
                    results[doc.id] = { name: doc.fileName, format: docFormat };

                    const statusElement = document.getElementById('status-' + doc.id);
                    if (doc.status === 'Ready') {
                        statusElement.textContent = 'Ready';
                        statusElement.className = 'status-ready';
                        statusElement.onclick = null;
                        const startBtn = document.getElementById('start-' + doc.id);
                        if (startBtn) { startBtn.style.display = 'inline'; }
                    } else if (doc.status === 'Processing') {
                        let progressText = 'Processing...';
                        if (doc.progress !== undefined && doc.progress !== null) {
                            progressText = 'Processing ' + doc.progress + '%';
                        }
                        statusElement.innerHTML = '<div class="progress-container"><div class="progress-wheel"></div><span>' + progressText + '</span></div>';
                        statusElement.className = 'status-processing';
                        statusElement.onclick = null;
                        const startBtn = document.getElementById('start-' + doc.id);
                        if (startBtn) { startBtn.style.display = 'none'; }
                        pollResult(doc.id, doc.fileName);
                    } else if (doc.status === 'Queued') {
                        statusElement.textContent = 'Queued...';
                        statusElement.className = 'status-queued';
                        statusElement.onclick = null;
                        const startBtn = document.getElementById('start-' + doc.id);
                        if (startBtn) { startBtn.style.display = 'none'; }
                        pollResult(doc.id, doc.fileName);
                    } else if (doc.status === 'Error') {
                        statusElement.textContent = 'Error (click for details)';
                        statusElement.className = 'status-error';
                        statusElement.onclick = () => showErrorDetails(doc.id, doc.fileName);
                        const startBtn = document.getElementById('start-' + doc.id);
                        if (startBtn) { startBtn.style.display = 'inline'; }
                    } else {
                        statusElement.innerHTML = '<span style="color: orange; font-weight: bold;">STATUS: ' + (doc.status || 'UNDEFINED') + '</span>';
                    }
                });
            }
        } catch (error) {
            console.error('Failed to load existing documents:', error);
        }
    }

    async function loadProcessedFiles() {
        try {
            const [filesResponse, documentsResponse] = await Promise.all([
                fetch(API + '/api/files'),
                fetch(API + '/api/documents')
            ]);

            if (!filesResponse.ok && !documentsResponse.ok) {
                const filesList = document.getElementById('files-list');
                filesList.innerHTML = '<p style="color: #fbbf24;">Server responded with an error. Checking connection...</p>';
                setTimeout(() => checkHealth(1), 2000);
                return;
            }

            const allItems = [];
            let documentsMap = new Map();
            if (documentsResponse.ok) {
                const documents = await documentsResponse.json();
                documents.filter(doc => doc.status === 'Completed').forEach(doc => {
                    documentsMap.set(doc.id, doc);
                    // Clean up completed items from Processing Results section
                    const resultItem = document.getElementById('result-item-' + doc.id);
                    if (resultItem) {
                        resultItem.style.transition = 'opacity 0.3s';
                        resultItem.style.opacity = '0';
                        setTimeout(() => {
                            resultItem.remove();
                            const resultsList = document.getElementById('results-list');
                            if (resultsList && resultsList.children.length === 0) {
                                resultsList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No documents in processing. Upload files above to get started.</p>';
                            }
                        }, 300);
                    }
                });
            }

            const filesByDocId = new Map();
            if (filesResponse.ok) {
                let files = await filesResponse.json();
                if (!Array.isArray(files)) files = [files];

                files.forEach(file => {
                    const isGeneratedFile = /\.(md|xml|html|json|png|jpg|jpeg|gif|bmp|tiff|webp)$/i.test(file.fileName);
                    if (isGeneratedFile) {
                        if (!filesByDocId.has(file.id)) { filesByDocId.set(file.id, []); }
                        filesByDocId.get(file.id).push(file);
                    }
                });
            }

            filesByDocId.forEach((files, docId) => {
                const correspondingDoc = documentsMap.get(docId);
                allItems.push({
                    type: 'document',
                    id: docId,
                    files: files,
                    fileCount: files.length,
                    lastModified: files[0].lastModified,
                    totalSize: files.reduce((sum, f) => {
                        const sizeNum = parseFloat(f.fileSize.replace(' KB', ''));
                        return sum + sizeNum;
                    }, 0),
                    exportFormat: correspondingDoc ? correspondingDoc.exportFormat : 'unknown',
                    canReprocess: !!correspondingDoc,
                    originalFileName: correspondingDoc ? correspondingDoc.fileName : 'Unknown'
                });
            });

            const filesList = document.getElementById('files-list');
            if (allItems.length === 0) {
                filesList.innerHTML = '<p style="color: #b0b0b0; font-style: italic;">No processed files found.</p>';
                return;
            }

            filesList.innerHTML = allItems.map(item => {
                const escapedId = item.id.replace(/'/g, "\\'");
                const escapedFileName = item.originalFileName.replace(/'/g, "\\'");
                const fileListHtml = item.files.map(f =>
                    '<li style="color: #b0b0b0; font-size: 0.9em;">' + f.fileName + ' (' + f.fileSize + ')</li>'
                ).join('');

                return '<div class="result-item">' +
                    '<div style="flex: 1;">' +
                    '<strong>' + item.originalFileName + '</strong><br>' +
                    '<small style="color: #b0b0b0;">' +
                    item.fileCount + ' file' + (item.fileCount > 1 ? 's' : '') + ' | ' +
                    item.totalSize.toFixed(2) + ' KB total | Modified: ' + item.lastModified +
                    '</small>' +
                    '<details style="margin-top: 8px;">' +
                    '<summary style="cursor: pointer; color: #049fd9; font-size: 0.9em;">Show files</summary>' +
                    '<ul style="margin: 8px 0 0 20px; padding: 0;">' + fileListHtml + '</ul>' +
                    '</details>' +
                    '</div>' +
                    '<div style="display: flex; gap: 8px; align-items: flex-start;">' +
                    '<button onclick="downloadAllFilesForDocument(\'' + escapedId + '\', \'' + escapedFileName + '\')" style="padding: 6px 12px; background: #0073e6; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">Download</button>' +
                    (item.canReprocess ? '<button class="reprocess-btn" onclick="reprocessFromCompleted(\'' + escapedId + '\', \'' + escapedFileName + '\')" style="white-space: nowrap;">Re-process</button>' : '') +
                    '</div>' +
                    '</div>';
            }).join('');
        } catch (error) {
            console.error('Failed to load processed files:', error);
            document.getElementById('files-list').innerHTML = '<p style="color: #fbbf24;">Connection lost. Attempting to reconnect...</p>';
            setTimeout(() => checkHealth(1), 2000);
        }
    }

    async function checkHealth(retries = 3) {
        try {
            const timeoutPromise = new Promise((_, reject) => { setTimeout(() => reject(new Error('Timeout')), 5000); });
            const response = await Promise.race([ fetch(API + '/api/health'), timeoutPromise ]);
            if (response.ok) {
                document.getElementById('status').textContent = 'Connected';
                document.getElementById('status').style.color = '#00bceb';
                if (document.getElementById('files-list').innerHTML.includes('Connection lost') ||
                    document.getElementById('files-list').innerHTML.includes('Server responded with an error')) {
                    loadProcessedFiles();
                }
                return true;
            } else {
                document.getElementById('status').textContent = 'Server Error';
                document.getElementById('status').style.color = '#ef4444';
                return false;
            }
        } catch (error) {
            if (retries > 0) {
                document.getElementById('status').textContent = 'Connecting...';
                document.getElementById('status').style.color = '#fbbf24';
                await new Promise(resolve => setTimeout(resolve, 2000));
                return checkHealth(retries - 1);
            } else {
                document.getElementById('status').textContent = 'Disconnected';
                document.getElementById('status').style.color = '#ef4444';
                return false;
            }
        }
    }

    async function reprocessFromCompleted(documentId, fileName) {
        try {
            const documentsResponse = await fetch(API + '/api/documents');
            if (documentsResponse.ok) {
                const documents = await documentsResponse.json();
                const doc = documents.find(d => d.id === documentId);
                if (doc) {
                    const docFormat = doc.exportFormat || 'markdown';
                    addResult(documentId, fileName, docFormat);
                    results[documentId] = { name: fileName, format: docFormat };

                    const statusElement = document.getElementById('status-' + documentId);
                    statusElement.textContent = 'Ready';
                    statusElement.className = 'status-ready';
                    statusElement.onclick = null;

                    const startBtn = document.getElementById('start-' + documentId);
                    if (startBtn) { startBtn.style.display = 'inline'; }

                    await fetch(API + '/api/documents/' + documentId + '/reset', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: 'Ready' })
                    });

                    loadProcessedFiles();

                    const processingSection = document.getElementById('results');
                    if (processingSection) {
                        processingSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                } else {
                    throw new Error('Document not found');
                }
            } else {
                throw new Error('Failed to get document details');
            }
        } catch (error) {
            alert('Error moving document back to Processing Results: ' + error.message);
        }
    }

    async function downloadDocument(docId) {
        try {
            const response = await fetch(API + '/api/download/' + docId);
            if (!response.ok) { throw new Error('Download failed'); }
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = docId + '.zip';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Download failed:', error);
            alert('Failed to download document. Please try again.');
        }
    }

    async function cancelProcessing(id, name) {
        if (!confirm('Are you sure you want to cancel processing "' + name + '"?')) { return; }
        try {
            const response = await fetch(API + '/api/cancel/' + id, { method: 'POST' });
            if (response.ok) {
                alert('Cancellation requested. The process will stop shortly.');
                const statusElement = document.getElementById('status-' + id);
                statusElement.textContent = 'Cancelling...';
                statusElement.className = 'status-error';
                const cancelBtn = document.getElementById('cancel-' + id);
                if (cancelBtn) { cancelBtn.remove(); }
                updateStats();
            } else {
                const error = await response.json();
                alert('Failed to cancel: ' + (error.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Cancel error:', error);
            alert('Failed to cancel processing. Please try again.');
        }
    }

    async function downloadAllFilesForDocument(docId, originalFileName) {
        try {
            const response = await fetch(API + '/api/download/' + docId);
            if (!response.ok) { throw new Error('Download failed'); }
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Use original filename without extension, add .zip
            const baseFileName = originalFileName.replace(/\.[^/.]+$/, '');
            a.download = baseFileName + '.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Download all files failed:', error);
            alert('Failed to download files: ' + error.message);
        }
    }

    async function downloadSingleFile(downloadUrl, fileName) {
        const downloadPath = downloadUrl.startsWith('/') ? downloadUrl : '/' + downloadUrl;
        const response = await fetch(API + downloadPath);
        if (!response.ok) { throw new Error('Download failed for ' + fileName + ' with status ' + response.status); }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = fileName;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function downloadProcessedFile(downloadUrl, fileName) {
        try {
            const downloadPath = downloadUrl.startsWith('/') ? downloadUrl : '/' + downloadUrl;
            const response = await fetch(API + downloadPath);
            if (!response.ok) { throw new Error('Download failed with status ' + response.status); }
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = fileName;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Download failed:', error);
            alert('Failed to download file: ' + error.message);
        }
    }

    async function downloadAllDocuments() {
        try {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Preparing...'; btn.disabled = true;

            const response = await fetch(API + '/api/download-all');
            if (!response.ok) { throw new Error('Download failed'); }

            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = 'PSDocling_Export_' + timestamp + '.zip';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);

            btn.textContent = originalText; btn.disabled = false;
        } catch (error) {
            console.error('Download all failed:', error);
            alert('Failed to download all documents. Please try again.');
            if (event && event.target) { event.target.textContent = 'Download All'; event.target.disabled = false; }
        }
    }
    </script>
</body>
</html>
